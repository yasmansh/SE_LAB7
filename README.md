
 # آزمایش هفتم آزمایشگاه مهندسی نرم‌افزار
عنوان آزمایش:
بازآرایی کد (Refactoring) 
 ## اعضای گروه
 یاسمن شیخان - 97101915 و امیرحسین علی‌محمدی - 97110166
 
 
سوال 1:

بخش a ) تعریف clean code : به کدی که خوانایی بالایی داشته و فهم آن آسان باشد و به راحتی تغییر کند clean code می گویند. درواقع کدی که توسعه و نگهداری و تست آن آسان باشد.

بخش b ) تعریف technical debt : Technical Debt که تحت عناوین دیگری همچون Design Debt و Code Debt نیز از آن یاد می‌شود، اصطلاحی در صنعت توسعهٔ نرم‌افزار است که طی آن دولوپر به جای صَرف زمان زیاد و یافتن درست‌ترین و بهترین راه‌حل در حین کدنویسی، یک راه‌حل آسان و فوری را برای حل موقت یک مسئله به کار می‌گیرد و در عوض متعهد می‌گردد که در آینده و پس از تکمیل پروژه، زمانی را برای یافتن راه‌حلی اصولی‌تر و حتی تغییر بخشی از کد‌ها جهت جایگزین نمودن راه‌حل درست با راه‌حل موقت صرف نماید که این رویکرد را شاید بتوان چیزی شبیه بهره‌ٔ وام در نظر گرفت.

بخش c ) تعریف bad smell : بوی بد اصطلاحی است که برای کدنویسی نامرتب یا کثیف استفاده شده است، این اصطلاح می گوید بخشی از کد وجود دارد که در آینده باید refactor شود. درواقع به نشانه هایی در کد که احتمال وجود مشکلات جدی در آینده را نسان میدهند بوی بد میگویند.

سوال 2 :

دسته Bloaters:
وقتی حجم کد، متدها و کلاس‌ها به قدری زیاد شود که کار کردن با آن‌ها سخت باشد در این دسته از بوهای بد قرار میگیرند. معمولا این دسته‌ از بوها با اضافه کردن فیچرهای جدید و توسعه کد درطول زمان به وجود می‌آیند. 
از این دسته میتوان به Long Method، Large Class، Primitive Obsession، Long Parameter List و Data Clumps اشاره کرد.



دسته Object-Orientation Abusers:
این دسته از بوها شامل کاربرد ناقص یا کاربرد نادرست اصول برنامه نویسی شی گرا هستند.
از این دسته میتوان به Alternative Classes with Different Interfaces ،Refused Bequest ،Switch Statements ،Temporary Field اشاره کرد. به طور مثال Switch Statements به داشتن سوییچ کیس پیچیده یا دنباله‌ای طولانی از ifها میگویند.


دسته Change Preventers:
این دسته از بوها به این معنی است که اگر شما نیاز به تغییر چیزی در یک مکان در کد خود دارید، باید در جاهای دیگر نیز تغییرات زیادی ایجاد کنید. در نتیجه توسعه برنامه بسیار پیچیده تر و گران تر می شود. ااز نمونه های ان میتوان به Divergent Change،
Parallel Inheritance Hierarchies و 
Shotgun Surgery اشاره کرد.


دسته Dispensables:
بخش‌هایی از برنامه هستند که بدون کاربرد، بی‌معنی و غیر ضروری است که نبود آن کد را تمیزتر، کارآمدتر و درک آسان‌تر می‌کند.
از این دسته میتوان به Comments، Duplicate Code، Data Class، Dead Code، Lazy Class، Speculative Generality اشاره کرد.

دسته Couplers:
این دسته از بوها به جفت شدن بیش از حد بین کلاس ها کمک می کند یا نشان می دهد که اگر جفت با تفویض بیش از حد جایگزین شود چه اتفاقی می افتد. درواقع منجر به coupling بیش از حد بین کلاس‌ها و ماژول ها میشوند. از این دسته میتوان به Feature Envy، Inappropriate Intimacy، Incomplete Library Class، Message Chains، Middle Man اشاره کرد.


سوال 3:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#گزارش:
Loose coupling: 
هنگام new کردن تایپ مورد نظر را می سازد اما موقع ساخت خود Field از interface سوپر کلاسش استفاده می کند. 
برای این کار در کلاس های Memory و ParseTable و Parser و Rule و SymbolTable فیلدی از جنس List ساختیم و فقط موقع new کردن از ArrayList استفاده کردیم.

Separate Query from Modifier:
در کلاس ParserTable دو متد createTables و createTokens را ساختیم و به این ترتیب متد بزرگتر را به چند متد کوچکتر شکاندیم.

Self Encapsulated Field:
در کلاس lexicalAnalyzer برای فیلد matcher دو تابع getter و setter را ساختیم و هر جایی که به طور مستقیم این فیلد را تعیین و دریافت می کردیم با این دو تابع جایگزین کردیم. همچنین در فایل Token برای دو فیلد type و value مشابه همین کار را کردیم.

Inline Temp:
برای این کار باید تابعی را پیدا کنیم که متغیر temp ای را بر اساس عبارت ساده ای set کرده است و همان temp را خروجی می دهد. در نتیجه برای بازآرایی کد می توان عبارت معادلی که بدون استفاده از temp همان جواب را می دهد return کرد.
در فایل Token برای متد hashcode متغیر result را حذف کردیم.

Facade:
باید کلاسی را پیدا کنیم که در آن به طور مستقیم وابستگی به کلاس دیگری از پکیج دیگری وجود داشته باشد و باید سعی کنیم از پکیج سومی به نام facade استفاده کنیم که این وابستگی را رفع کرده و از پیچیدگی های تعداد زیادی متد در پروژه های بزرگ جلوگیری کنیم. 
کلاس های پکیج facade به عنوان واسط بین دو پکیج دیگر عمل می کنند و قابلیت توسعه کد را بیشتر می کنند.
facade 1:
وابستگی Parser به کلاس CodeGenerator را حذف کردیم و از CodeGeneratorFacade استفاده کردیم. در این کلاس جدید متد های getCodeGeneratorFacade و createSemantic و printMemory را تعریف کردیم.

facade 2:
وابستگی فایل SymbolTable برای فیلد mem را از طریق واسط MemoryFacade که ساختیم از بین بردیم. 
همچنین متد های setMemory و getMemory را در فایل جدید پیاده سازی کردیم.

facade 3:
برای فیلد lookihead در کلاس Parser به طور مستقیم به کلاس Token وابسته بودیم ولی با ایجاد کلاس TokenFacade در پکیج Facade این مورد را برطرف کردیم.
همچنین متدهای setToken و getTokenو  getTokenFacade را پیاده سازی کردیم.


Facade 
